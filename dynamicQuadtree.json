{
  "id": "dynamicQuadtree",
  "name": "Dynamic Quadtree Explorer",
  "version": "1.0",
  "icon": "⊞",
  "description": "Memory-dynamic quadtree system with strict square geometry for scientific exploration",
  "author": "System",
  "desktopIcon": true,
  "code": "// Initialize app state with precise memory structure\nvar state = {\n  quadtrees: {\n    'root': {\n      id: 'root',\n      name: 'Main Quadtree',\n      children: null,\n      content: null,\n      color: '#1a1a1a',\n      textContent: '',\n      image: null,\n      dictionaryEntries: []\n    }\n  },\n  currentQuadtreeId: 'root',\n  history: ['root'],\n  dictionary: {},\n  settings: {\n    maxDepth: 8,\n    defaultCellColor: '#1a1a1a',\n    showGrid: true,\n    gridColor: '#333333',\n    zoomLevel: 1.0,\n    panOffset: { x: 0, y: 0 },\n    enforceSquareImages: true\n  },\n  activeCell: null,\n  selectedDictionaryEntry: null,\n  viewMode: 'explore', // 'explore', 'dictionary'\n  modified: false,\n  memoryPointers: {}, // For precise memory management\n  canvasSize: 512 // Base canvas size\n};\n\n// Create main UI\nvar container = app.rootElement;\ncontainer.style.display = 'flex';\ncontainer.style.flexDirection = 'column';\ncontainer.style.height = '100%';\ncontainer.style.overflow = 'hidden';\ncontainer.style.backgroundColor = '#111';\ncontainer.style.color = 'var(--main-text)';\ncontainer.style.fontFamily = 'monospace';\n\n// Create toolbar\nvar toolbar = document.createElement('div');\ntoolbar.style.padding = '5px';\ntoolbar.style.borderBottom = '1px solid var(--main-border)';\ntoolbar.style.display = 'flex';\ntoolbar.style.flexWrap = 'wrap';\ntoolbar.style.gap = '5px';\n\n// Toolbar - File operations\nvar newBtn = createButton('New', function() { newQuadtree(); });\nvar openBtn = createButton('Open', function() { openQuadtree(); });\nvar saveBtn = createButton('Save', function() { saveQuadtree(); });\nvar exportBtn = createButton('Export', function() { exportToJson(); });\nvar importBtn = createButton('Import', function() { importFromJson(); });\n\n// Toolbar - View operations\nvar backBtn = createButton('◀ Back', function() { navigateBack(); });\nbackBtn.style.marginLeft = '15px';\n\nvar modeToggleBtn = createButton('Dictionary', function() { toggleViewMode(); });\n\n// Toolbar - Navigation controls\nvar zoomInBtn = createButton('Zoom +', function() { zoomIn(); });\nvar zoomOutBtn = createButton('Zoom −', function() { zoomOut(); });\nvar resetViewBtn = createButton('Reset View', function() { resetView(); });\n\nvar settingsBtn = createButton('Settings', function() { showSettings(); });\n\nvar helpBtn = createButton('Help', function() { showHelp(); });\n\n// Add buttons to toolbar\ntoolbar.appendChild(newBtn);\ntoolbar.appendChild(openBtn);\ntoolbar.appendChild(saveBtn);\ntoolbar.appendChild(exportBtn);\ntoolbar.appendChild(importBtn);\ntoolbar.appendChild(backBtn);\ntoolbar.appendChild(zoomInBtn);\ntoolbar.appendChild(zoomOutBtn);\ntoolbar.appendChild(resetViewBtn);\ntoolbar.appendChild(modeToggleBtn);\ntoolbar.appendChild(settingsBtn);\ntoolbar.appendChild(helpBtn);\n\n// Main content area with quadtree and info panel\nvar contentArea = document.createElement('div');\ncontentArea.style.display = 'flex';\ncontentArea.style.flex = '1';\ncontentArea.style.overflow = 'hidden';\n\n// Quadtree canvas container (ensures square aspect ratio)\nvar canvasContainer = document.createElement('div');\ncanvasContainer.style.flex = '1';\ncanvasContainer.style.position = 'relative';\ncanvasContainer.style.overflow = 'hidden';\ncanvasContainer.style.display = 'flex';\ncanvasContainer.style.justifyContent = 'center';\ncanvasContainer.style.alignItems = 'center';\n\n// Create square canvas wrapper to enforce aspect ratio\nvar canvasWrapper = document.createElement('div');\ncanvasWrapper.style.position = 'relative';\ncanvasWrapper.style.width = '100%';\ncanvasWrapper.style.height = '100%';\ncanvasWrapper.style.maxWidth = '100%';\ncanvasWrapper.style.maxHeight = '100%';\ncanvasContainer.appendChild(canvasWrapper);\n\n// Create canvas for quadtree rendering\nvar canvas = document.createElement('canvas');\ncanvas.width = state.canvasSize;\ncanvas.height = state.canvasSize;\ncanvas.style.position = 'absolute';\ncanvas.style.cursor = 'pointer';\ncanvasWrapper.appendChild(canvas);\n\n// Info panel\nvar infoPanel = document.createElement('div');\ninfoPanel.style.width = '300px';\ninfoPanel.style.padding = '10px';\ninfoPanel.style.borderLeft = '1px solid var(--main-border)';\ninfoPanel.style.overflow = 'auto';\n\n// Dictionary panel (hidden initially)\nvar dictionaryPanel = document.createElement('div');\ndictionaryPanel.style.flex = '1';\ndictionaryPanel.style.display = 'none';\ndictionaryPanel.style.flexDirection = 'column';\ndictionaryPanel.style.overflow = 'hidden';\n\n// Status bar\nvar statusBar = document.createElement('div');\nstatusBar.style.padding = '3px 5px';\nstatusBar.style.borderTop = '1px solid var(--main-border)';\nstatusBar.style.fontSize = '12px';\nstatusBar.style.display = 'flex';\nstatusBar.style.justifyContent = 'space-between';\n\nvar statusLeft = document.createElement('span');\nstatusLeft.textContent = 'Ready';\n\nvar statusRight = document.createElement('span');\nstatusRight.textContent = 'Zoom: 100%';\n\nstatusBar.appendChild(statusLeft);\nstatusBar.appendChild(statusRight);\n\n// Assemble UI\ncontentArea.appendChild(canvasContainer);\ncontentArea.appendChild(infoPanel);\ncontentArea.appendChild(dictionaryPanel);\n\ncontainer.appendChild(toolbar);\ncontainer.appendChild(contentArea);\ncontainer.appendChild(statusBar);\n\n// Helper function to create buttons\nfunction createButton(text, onClick) {\n  var btn = document.createElement('button');\n  btn.textContent = text;\n  btn.onclick = onClick;\n  return btn;\n}\n\n// Maintain square aspect ratio for canvas\nfunction maintainSquareAspect() {\n  var container = canvasWrapper;\n  var parentWidth = canvasContainer.clientWidth;\n  var parentHeight = canvasContainer.clientHeight;\n  \n  var size = Math.min(parentWidth, parentHeight);\n  container.style.width = size + 'px';\n  container.style.height = size + 'px';\n  \n  // Position in center\n  container.style.position = 'absolute';\n  if (parentWidth > size) {\n    container.style.left = ((parentWidth - size) / 2) + 'px';\n  } else {\n    container.style.left = '0';\n  }\n  \n  if (parentHeight > size) {\n    container.style.top = ((parentHeight - size) / 2) + 'px';\n  } else {\n    container.style.top = '0';\n  }\n}\n\n// Canvas event handlers\ncanvas.onclick = function(e) {\n  handleCanvasClick(e);\n};\n\ncanvas.onmousemove = function(e) {\n  // Implement hover highlighting here if needed\n};\n\n// Add pan support with mouse drag\nvar isDragging = false;\nvar lastMousePos = { x: 0, y: 0 };\n\ncanvas.onmousedown = function(e) {\n  isDragging = true;\n  lastMousePos.x = e.clientX;\n  lastMousePos.y = e.clientY;\n  canvas.style.cursor = 'grabbing';\n};\n\ncanvas.onmouseup = function() {\n  isDragging = false;\n  canvas.style.cursor = 'pointer';\n};\n\ncanvas.onmouseleave = function() {\n  isDragging = false;\n  canvas.style.cursor = 'pointer';\n};\n\ncanvas.onmousemove = function(e) {\n  if (isDragging) {\n    var dx = e.clientX - lastMousePos.x;\n    var dy = e.clientY - lastMousePos.y;\n    \n    // Scale pan speed by zoom level\n    state.settings.panOffset.x += dx / state.settings.zoomLevel;\n    state.settings.panOffset.y += dy / state.settings.zoomLevel;\n    \n    lastMousePos.x = e.clientX;\n    lastMousePos.y = e.clientY;\n    \n    renderQuadtree();\n  }\n};\n\n// Add keyboard shortcuts\ndocument.addEventListener('keydown', function(e) {\n  // Only process if not in a text field\n  if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {\n    // Arrow keys for navigation\n    var panAmount = 20 / state.settings.zoomLevel;\n    \n    if (e.key === 'ArrowLeft') {\n      state.settings.panOffset.x += panAmount;\n      renderQuadtree();\n    } else if (e.key === 'ArrowRight') {\n      state.settings.panOffset.x -= panAmount;\n      renderQuadtree();\n    } else if (e.key === 'ArrowUp') {\n      state.settings.panOffset.y += panAmount;\n      renderQuadtree();\n    } else if (e.key === 'ArrowDown') {\n      state.settings.panOffset.y -= panAmount;\n      renderQuadtree();\n    }\n    \n    // Zoom controls\n    if (e.key === '+' || e.key === '=') {\n      zoomIn();\n    } else if (e.key === '-' || e.key === '_') {\n      zoomOut();\n    }\n    \n    // Reset view with 'r'\n    if (e.key === 'r') {\n      resetView();\n    }\n    \n    // Back navigation with 'b'\n    if (e.key === 'b') {\n      navigateBack();\n    }\n    \n    // Enter cell with 'Enter'\n    if (e.key === 'Enter' && state.activeCell) {\n      enterCell(state.activeCell);\n    }\n  }\n});\n\n// Set up the info panel content\nfunction setupInfoPanel() {\n  infoPanel.innerHTML = '';\n  \n  var title = document.createElement('h3');\n  title.textContent = 'Cell Properties';\n  title.style.margin = '0 0 10px 0';\n  \n  var propContainer = document.createElement('div');\n  propContainer.style.marginBottom = '15px';\n  \n  // Add path display to show current cell location\n  var pathDisplay = document.createElement('div');\n  pathDisplay.style.fontFamily = 'monospace';\n  pathDisplay.style.padding = '5px';\n  pathDisplay.style.backgroundColor = '#222';\n  pathDisplay.style.marginBottom = '10px';\n  pathDisplay.style.wordBreak = 'break-all';\n  pathDisplay.style.fontSize = '12px';\n  \n  if (state.activeCell) {\n    pathDisplay.textContent = getCellPath(state.activeCell);\n  } else {\n    pathDisplay.textContent = 'No cell selected';\n  }\n  \n  // Color picker\n  var colorLabel = document.createElement('label');\n  colorLabel.textContent = 'Background Color:';\n  colorLabel.style.display = 'block';\n  colorLabel.style.marginBottom = '5px';\n  \n  var colorPicker = document.createElement('input');\n  colorPicker.type = 'color';\n  colorPicker.value = state.settings.defaultCellColor;\n  colorPicker.style.width = '100%';\n  colorPicker.style.marginBottom = '10px';\n  colorPicker.onchange = function() {\n    if (state.activeCell) {\n      var cell = getCell(state.activeCell);\n      if (cell) {\n        cell.color = colorPicker.value;\n        state.modified = true;\n        renderQuadtree();\n      }\n    }\n  };\n  \n  // Text content\n  var textLabel = document.createElement('label');\n  textLabel.textContent = 'Text Content:';\n  textLabel.style.display = 'block';\n  textLabel.style.marginBottom = '5px';\n  \n  var textArea = document.createElement('textarea');\n  textArea.style.width = '100%';\n  textArea.style.height = '60px';\n  textArea.style.marginBottom = '10px';\n  textArea.style.resize = 'vertical';\n  textArea.oninput = function() {\n    if (state.activeCell) {\n      var cell = getCell(state.activeCell);\n      if (cell) {\n        cell.textContent = textArea.value;\n        state.modified = true;\n        renderQuadtree();\n      }\n    }\n  };\n  \n  // Image upload\n  var imageLabel = document.createElement('label');\n  imageLabel.textContent = 'Square Image:';\n  imageLabel.style.display = 'block';\n  imageLabel.style.marginBottom = '5px';\n  \n  var imagePreview = document.createElement('div');\n  imagePreview.style.width = '100%';\n  imagePreview.style.height = '200px';\n  imagePreview.style.border = '1px dashed #555';\n  imagePreview.style.marginBottom = '5px';\n  imagePreview.style.backgroundSize = 'contain';\n  imagePreview.style.backgroundPosition = 'center';\n  imagePreview.style.backgroundRepeat = 'no-repeat';\n  imagePreview.style.position = 'relative';\n  \n  var squareNote = document.createElement('div');\n  squareNote.textContent = 'Images will be cropped to square';\n  squareNote.style.position = 'absolute';\n  squareNote.style.bottom = '5px';\n  squareNote.style.right = '5px';\n  squareNote.style.backgroundColor = 'rgba(0,0,0,0.7)';\n  squareNote.style.padding = '3px 5px';\n  squareNote.style.borderRadius = '3px';\n  squareNote.style.fontSize = '10px';\n  imagePreview.appendChild(squareNote);\n  \n  var imageBtns = document.createElement('div');\n  imageBtns.style.display = 'flex';\n  imageBtns.style.gap = '5px';\n  imageBtns.style.marginBottom = '10px';\n  \n  var uploadBtn = createButton('Upload', function() {\n    if (!state.activeCell) return;\n    \n    // Create a file input element\n    var fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.accept = 'image/*';\n    fileInput.style.display = 'none';\n    document.body.appendChild(fileInput);\n    \n    fileInput.onchange = function() {\n      if (!fileInput.files || !fileInput.files[0]) {\n        document.body.removeChild(fileInput);\n        return;\n      }\n      \n      var reader = new FileReader();\n      reader.onload = function(e) {\n        processSquareImage(e.target.result, function(squareImageData) {\n          var cell = getCell(state.activeCell);\n          if (cell) {\n            cell.image = squareImageData;\n            imagePreview.style.backgroundImage = 'url(' + squareImageData + ')';\n            state.modified = true;\n            renderQuadtree();\n          }\n          document.body.removeChild(fileInput);\n        });\n      };\n      reader.readAsDataURL(fileInput.files[0]);\n    };\n    \n    fileInput.click();\n  });\n  \n  var pasteBtn = createButton('Paste', function() {\n    if (!state.activeCell) return;\n    \n    app.api.ui.alert('Please paste an image URL or data URL into the prompt.');\n    \n    var imgUrl = app.api.ui.prompt('Paste image URL or data URL:');\n    if (imgUrl) {\n      processSquareImage(imgUrl, function(squareImageData) {\n        var cell = getCell(state.activeCell);\n        if (cell) {\n          cell.image = squareImageData;\n          imagePreview.style.backgroundImage = 'url(' + squareImageData + ')';\n          state.modified = true;\n          renderQuadtree();\n        }\n      });\n    }\n  });\n  \n  var clearImgBtn = createButton('Clear', function() {\n    if (!state.activeCell) return;\n    \n    var cell = getCell(state.activeCell);\n    if (cell) {\n      cell.image = null;\n      imagePreview.style.backgroundImage = 'none';\n      state.modified = true;\n      renderQuadtree();\n    }\n  });\n  \n  imageBtns.appendChild(uploadBtn);\n  imageBtns.appendChild(pasteBtn);\n  imageBtns.appendChild(clearImgBtn);\n  \n  // Cell operations\n  var opTitle = document.createElement('h3');\n  opTitle.textContent = 'Cell Operations';\n  opTitle.style.margin = '15px 0 10px 0';\n  \n  var opContainer = document.createElement('div');\n  opContainer.style.display = 'flex';\n  opContainer.style.flexDirection = 'column';\n  opContainer.style.gap = '5px';\n  \n  var splitBtn = createButton('Split Cell', function() {\n    if (!state.activeCell) return;\n    splitCell(state.activeCell);\n  });\n  \n  var enterBtn = createButton('Enter Cell', function() {\n    if (!state.activeCell) return;\n    enterCell(state.activeCell);\n  });\n  \n  var resetBtn = createButton('Reset Cell', function() {\n    if (!state.activeCell) return;\n    resetCell(state.activeCell);\n  });\n  \n  // Dictionary links\n  var dictTitle = document.createElement('h3');\n  dictTitle.textContent = 'Dictionary Entries';\n  dictTitle.style.margin = '15px 0 10px 0';\n  \n  var dictContainer = document.createElement('div');\n  dictContainer.style.marginBottom = '10px';\n  \n  var entryList = document.createElement('select');\n  entryList.style.width = '100%';\n  entryList.style.marginBottom = '5px';\n  entryList.size = 5; // Show more entries\n  \n  var dictBtns = document.createElement('div');\n  dictBtns.style.display = 'flex';\n  dictBtns.style.gap = '5px';\n  dictBtns.style.flexWrap = 'wrap';\n  \n  var linkBtn = createButton('Link Entry', function() {\n    if (!state.activeCell) return;\n    showDictionaryLinkDialog();\n  });\n  \n  var viewEntryBtn = createButton('View Entry', function() {\n    if (!entryList.value) return;\n    state.selectedDictionaryEntry = entryList.value;\n    toggleViewMode('dictionary');\n    updateDictionaryPanel();\n  });\n  \n  var unlinkBtn = createButton('Unlink', function() {\n    if (!state.activeCell || !entryList.value) return;\n    \n    var cell = getCell(state.activeCell);\n    if (cell && cell.dictionaryEntries) {\n      var index = cell.dictionaryEntries.indexOf(entryList.value);\n      if (index > -1) {\n        cell.dictionaryEntries.splice(index, 1);\n        updateInfoPanel();\n        state.modified = true;\n      }\n    }\n  });\n  \n  dictBtns.appendChild(linkBtn);\n  dictBtns.appendChild(viewEntryBtn);\n  dictBtns.appendChild(unlinkBtn);\n  \n  // Cell memory info (for debugging and advanced users)\n  var memoryTitle = document.createElement('h3');\n  memoryTitle.textContent = 'Memory Information';\n  memoryTitle.style.margin = '15px 0 10px 0';\n  \n  var memoryInfo = document.createElement('div');\n  memoryInfo.style.fontFamily = 'monospace';\n  memoryInfo.style.fontSize = '11px';\n  memoryInfo.style.padding = '5px';\n  memoryInfo.style.backgroundColor = '#222';\n  memoryInfo.style.maxHeight = '80px';\n  memoryInfo.style.overflow = 'auto';\n  \n  if (state.activeCell) {\n    var cell = getCell(state.activeCell);\n    if (cell) {\n      var pointer = state.memoryPointers[cell.id] || 'unknown';\n      var childCount = cell.children ? cell.children.length : 0;\n      var hasContent = cell.content ? 'yes' : 'no';\n      var memoryUsage = estimateCellMemory(cell);\n      \n      memoryInfo.innerHTML = \n        'ID: ' + cell.id + '<br>' +\n        'Memory Pointer: ' + pointer + '<br>' +\n        'Child Cells: ' + childCount + '<br>' +\n        'Has Nested Quadtree: ' + hasContent + '<br>' +\n        'Est. Memory Usage: ' + memoryUsage + ' bytes';\n    }\n  } else {\n    memoryInfo.textContent = 'No cell selected';\n  }\n  \n  // Add all elements to the info panel\n  propContainer.appendChild(pathDisplay);\n  propContainer.appendChild(colorLabel);\n  propContainer.appendChild(colorPicker);\n  propContainer.appendChild(textLabel);\n  propContainer.appendChild(textArea);\n  propContainer.appendChild(imageLabel);\n  propContainer.appendChild(imagePreview);\n  propContainer.appendChild(imageBtns);\n  \n  infoPanel.appendChild(title);\n  infoPanel.appendChild(propContainer);\n  infoPanel.appendChild(opTitle);\n  infoPanel.appendChild(opContainer);\n  opContainer.appendChild(splitBtn);\n  opContainer.appendChild(enterBtn);\n  opContainer.appendChild(resetBtn);\n  \n  infoPanel.appendChild(dictTitle);\n  infoPanel.appendChild(dictContainer);\n  dictContainer.appendChild(entryList);\n  dictContainer.appendChild(dictBtns);\n  \n  infoPanel.appendChild(memoryTitle);\n  infoPanel.appendChild(memoryInfo);\n  \n  // Update the info panel if a cell is active\n  if (state.activeCell) {\n    var cell = getCell(state.activeCell);\n    if (cell) {\n      colorPicker.value = cell.color || state.settings.defaultCellColor;\n      textArea.value = cell.textContent || '';\n      \n      if (cell.image) {\n        imagePreview.style.backgroundImage = 'url(' + cell.image + ')';\n      } else {\n        imagePreview.style.backgroundImage = 'none';\n      }\n      \n      // Populate dictionary entries\n      entryList.innerHTML = '';\n      if (cell.dictionaryEntries && cell.dictionaryEntries.length > 0) {\n        for (var i = 0; i < cell.dictionaryEntries.length; i++) {\n          var entryId = cell.dictionaryEntries[i];\n          var entry = state.dictionary[entryId];\n          if (entry) {\n            var option = document.createElement('option');\n            option.value = entryId;\n            option.textContent = entry.title;\n            entryList.appendChild(option);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Estimate cell memory usage (for display)\nfunction estimateCellMemory(cell) {\n  if (!cell) return 0;\n  \n  var size = 0;\n  \n  // Basic properties\n  size += (cell.id ? cell.id.length * 2 : 0); // Unicode is 2 bytes per char\n  size += (cell.name ? cell.name.length * 2 : 0);\n  size += (cell.textContent ? cell.textContent.length * 2 : 0);\n  size += (cell.color ? cell.color.length * 2 : 0);\n  size += 50; // Overhead for object structure\n  \n  // Image size (very rough estimate based on data URL length)\n  if (cell.image) {\n    size += Math.floor(cell.image.length * 0.75); // data URLs are about 33% larger than actual data\n  }\n  \n  // Dictionary entries (just the references)\n  if (cell.dictionaryEntries) {\n    size += cell.dictionaryEntries.length * 10;\n  }\n  \n  // Don't recurse into children or content to avoid excessive calculation\n  if (cell.children) {\n    size += 50; // Just count the reference overhead\n  }\n  \n  if (cell.content) {\n    size += 20; // Just count the reference overhead\n  }\n  \n  return size;\n}\n\n// Process image to ensure it's square (crop or pad if needed)\nfunction processSquareImage(imageUrl, callback) {\n  // Create an image element to load the image\n  var img = new Image();\n  img.crossOrigin = 'Anonymous'; // Try to handle cross-origin images\n  \n  img.onload = function() {\n    // Create a canvas to process the image\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    \n    // Determine dimensions for a square image\n    var size = Math.max(img.width, img.height);\n    canvas.width = size;\n    canvas.height = size;\n    \n    // Fill with background color\n    ctx.fillStyle = '#000';\n    ctx.fillRect(0, 0, size, size);\n    \n    // Calculate positioning to center the image\n    var offsetX = (size - img.width) / 2;\n    var offsetY = (size - img.height) / 2;\n    \n    // Draw the image centered in the square canvas\n    ctx.drawImage(img, offsetX, offsetY, img.width, img.height);\n    \n    // Get the square image as a data URL\n    var squareImageData = canvas.toDataURL('image/jpeg', 0.85);\n    callback(squareImageData);\n  };\n  \n  img.onerror = function() {\n    app.api.ui.alert('Error loading image. Please try another image.');\n    callback(null);\n  };\n  \n  // Start loading the image\n  img.src = imageUrl;\n}\n\n// Set up the dictionary panel\nfunction setupDictionaryPanel() {\n  dictionaryPanel.innerHTML = '';\n  \n  // Dictionary toolbar\n  var dictToolbar = document.createElement('div');\n  dictToolbar.style.padding = '5px';\n  dictToolbar.style.borderBottom = '1px solid var(--main-border)';\n  dictToolbar.style.display = 'flex';\n  dictToolbar.style.gap = '5px';\n  \n  var addEntryBtn = createButton('New Entry', function() {\n    createDictionaryEntry();\n  });\n  \n  var deleteEntryBtn = createButton('Delete Entry', function() {\n    if (state.selectedDictionaryEntry) {\n      deleteDictionaryEntry(state.selectedDictionaryEntry);\n    }\n  });\n  \n  var exportDictBtn = createButton('Export Dictionary', function() {\n    exportDictionary();\n  });\n  \n  var importDictBtn = createButton('Import Dictionary', function() {\n    importDictionary();\n  });\n  \n  var searchInput = document.createElement('input');\n  searchInput.type = 'text';\n  searchInput.placeholder = 'Search dictionary...';\n  searchInput.style.flex = '1';\n  searchInput.style.marginLeft = '10px';\n  searchInput.style.padding = '3px';\n  searchInput.oninput = function() {\n    filterDictionaryEntries(searchInput.value);\n  };\n  \n  dictToolbar.appendChild(addEntryBtn);\n  dictToolbar.appendChild(deleteEntryBtn);\n  dictToolbar.appendChild(exportDictBtn);\n  dictToolbar.appendChild(importDictBtn);\n  dictToolbar.appendChild(searchInput);\n  \n  // Dictionary content area\n  var dictContent = document.createElement('div');\n  dictContent.style.display = 'flex';\n  dictContent.style.flex = '1';\n  dictContent.style.overflow = 'hidden';\n  \n  // Entry list\n  var entryListContainer = document.createElement('div');\n  entryListContainer.style.width = '250px';\n  entryListContainer.style.borderRight = '1px solid var(--main-border)';\n  entryListContainer.style.overflow = 'auto';\n  \n  var entryList = document.createElement('div');\n  entryList.className = 'dictionary-entry-list';\n  entryListContainer.appendChild(entryList);\n  \n  // Entry details\n  var entryDetails = document.createElement('div');\n  entryDetails.style.flex = '1';\n  entryDetails.style.padding = '10px';\n  entryDetails.style.overflow = 'auto';\n  \n  dictContent.appendChild(entryListContainer);\n  dictContent.appendChild(entryDetails);\n  \n  dictionaryPanel.appendChild(dictToolbar);\n  dictionaryPanel.appendChild(dictContent);\n  \n  // Populate the entry list\n  populateDictionaryEntryList(entryList, entryDetails);\n}\n\nfunction populateDictionaryEntryList(listElement, detailsElement) {\n  listElement.innerHTML = '';\n  \n  // Sort entries alphabetically by title\n  var entries = [];\n  for (var id in state.dictionary) {\n    entries.push({\n      id: id,\n      title: state.dictionary[id].title\n    });\n  }\n  \n  entries.sort(function(a, b) {\n    return a.title.localeCompare(b.title);\n  });\n  \n  for (var i = 0; i < entries.length; i++) {\n    var entry = entries[i];\n    var entryItem = document.createElement('div');\n    entryItem.className = 'dictionary-entry';\n    entryItem.textContent = entry.title;\n    entryItem.style.padding = '8px 10px';\n    entryItem.style.cursor = 'pointer';\n    entryItem.style.borderBottom = '1px solid #333';\n    entryItem.dataset.id = entry.id;\n    \n    if (state.selectedDictionaryEntry === entry.id) {\n      entryItem.style.backgroundColor = '#333';\n      entryItem.style.borderLeft = '3px solid #007acc';\n    }\n    \n    // Use closure to capture entry id\n    (function(id) {\n      entryItem.onclick = function() {\n        var items = listElement.getElementsByClassName('dictionary-entry');\n        for (var j = 0; j < items.length; j++) {\n          items[j].style.backgroundColor = '';\n          items[j].style.borderLeft = '';\n        }\n        entryItem.style.backgroundColor = '#333';\n        entryItem.style.borderLeft = '3px solid #007acc';\n        state.selectedDictionaryEntry = id;\n        showDictionaryEntry(id, detailsElement);\n      };\n    })(entry.id);\n    \n    listElement.appendChild(entryItem);\n  }\n  \n  // If an entry is selected, show it\n  if (state.selectedDictionaryEntry && state.dictionary[state.selectedDictionaryEntry]) {\n    showDictionaryEntry(state.selectedDictionaryEntry, detailsElement);\n  } else if (entries.length > 0) {\n    // Show first entry if nothing selected\n    state.selectedDictionaryEntry = entries[0].id;\n    showDictionaryEntry(entries[0].id, detailsElement);\n    \n    // Highlight the first entry\n    var firstEntry = listElement.querySelector('.dictionary-entry');\n    if (firstEntry) {\n      firstEntry.style.backgroundColor = '#333';\n      firstEntry.style.borderLeft = '3px solid #007acc';\n    }\n  } else {\n    detailsElement.innerHTML = '<div style=\"padding: 20px; text-align: center;\"><p>No dictionary entries found.</p><p>Click \"New Entry\" to create your first entry.</p></div>';\n  }\n}\n\nfunction showDictionaryEntry(id, detailsElement) {\n  var entry = state.dictionary[id];\n  if (!entry) return;\n  \n  detailsElement.innerHTML = '';\n  \n  var header = document.createElement('div');\n  header.style.marginBottom = '15px';\n  \n  var title = document.createElement('input');\n  title.type = 'text';\n  title.value = entry.title;\n  title.style.fontSize = '18px';\n  title.style.fontWeight = 'bold';\n  title.style.width = '100%';\n  title.style.marginBottom = '5px';\n  title.style.padding = '5px';\n  title.oninput = function() {\n    entry.title = title.value;\n    entry.dateModified = new Date().toISOString();\n    state.modified = true;\n    \n    // Update the entry in the list without full refresh\n    var entryItem = document.querySelector('.dictionary-entry[data-id=\"' + id + '\"]');\n    if (entryItem) {\n      entryItem.textContent = title.value;\n    }\n  };\n  \n  var metaInfo = document.createElement('div');\n  metaInfo.style.fontSize = '11px';\n  metaInfo.style.color = '#999';\n  metaInfo.style.marginBottom = '10px';\n  \n  var created = new Date(entry.dateCreated);\n  var modified = new Date(entry.dateModified);\n  \n  metaInfo.textContent = 'Created: ' + created.toLocaleDateString() + ' ' + \n                        created.toLocaleTimeString() + \n                        ' | Modified: ' + modified.toLocaleDateString() + ' ' + \n                        modified.toLocaleTimeString();\n  \n  header.appendChild(title);\n  header.appendChild(metaInfo);\n  \n  var content = document.createElement('textarea');\n  content.value = entry.content || '';\n  content.style.width = '100%';\n  content.style.height = '250px';\n  content.style.marginBottom = '15px';\n  content.style.padding = '8px';\n  content.style.resize = 'vertical';\n  content.style.fontFamily = 'inherit';\n  content.oninput = function() {\n    entry.content = content.value;\n    entry.dateModified = new Date().toISOString();\n    state.modified = true;\n    metaInfo.textContent = 'Created: ' + created.toLocaleDateString() + ' ' + \n                          created.toLocaleTimeString() + \n                          ' | Modified: ' + new Date().toLocaleDateString() + ' ' + \n                          new Date().toLocaleTimeString();\n  };\n  \n  var metaSection = document.createElement('div');\n  metaSection.style.marginTop = '15px';\n  metaSection.style.borderTop = '1px solid #333';\n  metaSection.style.paddingTop = '10px';\n  \n  var metaTitle = document.createElement('h4');\n  metaTitle.textContent = 'Linked Cells';\n  metaTitle.style.marginBottom = '5px';\n  \n  var linkedCells = document.createElement('div');\n  linkedCells.style.marginBottom = '15px';\n  \n  // Find all cells that link to this dictionary entry\n  var cellList = [];\n  findCellsWithDictionaryEntry(state.quadtrees.root, id, cellList);\n  \n  if (cellList.length > 0) {\n    var list = document.createElement('div');\n    list.style.maxHeight = '150px';\n    list.style.overflow = 'auto';\n    list.style.border = '1px solid #333';\n    list.style.padding = '5px';\n    \n    for (var i = 0; i < cellList.length; i++) {\n      var item = document.createElement('div');\n      item.textContent = getCellPath(cellList[i]);\n      item.style.padding = '3px 5px';\n      item.style.cursor = 'pointer';\n      item.style.borderBottom = '1px solid #333';\n      \n      // Highlight on hover\n      item.onmouseover = function() {\n        this.style.backgroundColor = '#333';\n      };\n      item.onmouseout = function() {\n        this.style.backgroundColor = '';\n      };\n      \n      // Navigate to this cell when clicked\n      (function(cellId) {\n        item.onclick = function() {\n          navigateToCell(cellId);\n        };\n      })(cellList[i]);\n      \n      list.appendChild(item);\n    }\n    \n    linkedCells.appendChild(list);\n  } else {\n    linkedCells.textContent = 'No cells are linked to this entry.';\n  }\n  \n  metaSection.appendChild(metaTitle);\n  metaSection.appendChild(linkedCells);\n  \n  detailsElement.appendChild(header);\n  detailsElement.appendChild(content);\n  detailsElement.appendChild(metaSection);\n}\n\n// Navigate to a specific cell (from dictionary view)\nfunction navigateToCell(cellId) {\n  // Find the quadtree containing this cell\n  var path = cellId.split('/');\n  var currentId = path[0];\n  \n  // If this is in a nested quadtree, we need to navigate there first\n  if (currentId !== 'root' && state.quadtrees[currentId]) {\n    // Find the parent cell that contains this quadtree\n    var parentCellId = findParentCellForQuadtree(currentId);\n    if (parentCellId) {\n      // Navigate to the parent cell's quadtree\n      var parentPath = parentCellId.split('/');\n      var parentQuadtreeId = parentPath[0];\n      \n      // Set up navigation\n      state.history = ['root'];\n      if (parentQuadtreeId !== 'root') {\n        state.history.push(parentQuadtreeId);\n      }\n      state.currentQuadtreeId = currentId;\n    } else {\n      // Just go directly to this quadtree\n      state.history = ['root'];\n      state.currentQuadtreeId = currentId;\n    }\n  } else {\n    // Cell is in the root quadtree\n    state.history = ['root'];\n    state.currentQuadtreeId = 'root';\n  }\n  \n  // Switch to explore mode\n  toggleViewMode('explore');\n  \n  // Select the cell\n  state.activeCell = cellId;\n  updateInfoPanel();\n  renderQuadtree();\n}\n\n// Find the parent cell that contains a quadtree\nfunction findParentCellForQuadtree(quadtreeId) {\n  function search(node) {\n    if (!node) return null;\n    \n    if (node.content === quadtreeId) {\n      return node.id;\n    }\n    \n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        var result = search(node.children[i]);\n        if (result) return result;\n      }\n    }\n    \n    return null;\n  }\n  \n  // Search through all quadtrees\n  for (var id in state.quadtrees) {\n    if (id === quadtreeId) continue; // Skip the one we're looking for\n    \n    var result = search(state.quadtrees[id]);\n    if (result) return result;\n  }\n  \n  return null;\n}\n\nfunction findCellsWithDictionaryEntry(node, entryId, resultList) {\n  if (!node) return;\n  \n  if (node.dictionaryEntries && node.dictionaryEntries.indexOf(entryId) !== -1) {\n    resultList.push(node.id);\n  }\n  \n  if (node.children) {\n    for (var i = 0; i < node.children.length; i++) {\n      findCellsWithDictionaryEntry(node.children[i], entryId, resultList);\n    }\n  }\n}\n\nfunction getCellPath(cellId) {\n  var parts = cellId.split('/');\n  var path = [];\n  \n  // Convert part numbers to more readable format\n  for (var i = 0; i < parts.length; i++) {\n    if (i === 0) {\n      var quadtree = state.quadtrees[parts[i]];\n      path.push(quadtree ? quadtree.name : parts[i]);\n    } else {\n      // Convert quadrant numbers to more readable format\n      switch(parts[i]) {\n        case '0': path.push('Top-Left'); break;\n        case '1': path.push('Top-Right'); break;\n        case '2': path.push('Bottom-Left'); break;\n        case '3': path.push('Bottom-Right'); break;\n        default: path.push(parts[i]);\n      }\n    }\n  }\n  \n  return path.join(' > ');\n}\n\nfunction filterDictionaryEntries(searchText) {\n  var items = document.getElementsByClassName('dictionary-entry');\n  if (!searchText) {\n    // Show all entries\n    for (var i = 0; i < items.length; i++) {\n      items[i].style.display = 'block';\n    }\n    return;\n  }\n  \n  searchText = searchText.toLowerCase();\n  \n  // Filter entries\n  for (var i = 0; i < items.length; i++) {\n    var title = items[i].textContent.toLowerCase();\n    if (title.includes(searchText)) {\n      items[i].style.display = 'block';\n    } else {\n      items[i].style.display = 'none';\n    }\n  }\n}\n\nfunction createDictionaryEntry() {\n  var title = app.api.ui.prompt('Enter title for new dictionary entry:');\n  if (!title) return;\n  \n  var id = 'entry_' + Date.now();\n  state.dictionary[id] = {\n    id: id,\n    title: title,\n    content: '',\n    dateCreated: new Date().toISOString(),\n    dateModified: new Date().toISOString()\n  };\n  \n  // Register in memory pointers for tracking\n  state.memoryPointers[id] = 'dict_' + Object.keys(state.dictionary).length;\n  \n  state.selectedDictionaryEntry = id;\n  state.modified = true;\n  updateDictionaryPanel();\n}\n\nfunction deleteDictionaryEntry(id) {\n  if (!state.dictionary[id]) return;\n  \n  var confirm = app.api.ui.confirm('Delete entry \"' + state.dictionary[id].title + '\"? This will remove all references to this entry from all cells.');\n  if (!confirm) return;\n  \n  // Remove references from all cells\n  for (var qtId in state.quadtrees) {\n    removeEntryFromCell(state.quadtrees[qtId], id);\n  }\n  \n  // Remove from memory pointers\n  delete state.memoryPointers[id];\n  \n  delete state.dictionary[id];\n  \n  if (state.selectedDictionaryEntry === id) {\n    state.selectedDictionaryEntry = null;\n  }\n  \n  state.modified = true;\n  updateDictionaryPanel();\n  if (state.activeCell) {\n    updateInfoPanel();\n  }\n}\n\nfunction removeEntryFromCell(cell, entryId) {\n  if (!cell) return;\n  \n  if (cell.dictionaryEntries) {\n    var index = cell.dictionaryEntries.indexOf(entryId);\n    if (index !== -1) {\n      cell.dictionaryEntries.splice(index, 1);\n    }\n  }\n  \n  if (cell.children) {\n    for (var i = 0; i < cell.children.length; i++) {\n      removeEntryFromCell(cell.children[i], entryId);\n    }\n  }\n}\n\nfunction showDictionaryLinkDialog() {\n  if (!state.activeCell) return;\n  \n  var entries = [];\n  for (var id in state.dictionary) {\n    entries.push({\n      id: id,\n      title: state.dictionary[id].title\n    });\n  }\n  \n  if (entries.length === 0) {\n    var create = app.api.ui.confirm('No dictionary entries exist. Create one now?');\n    if (create) {\n      createDictionaryEntry();\n    }\n    return;\n  }\n  \n  // Sort entries alphabetically\n  entries.sort(function(a, b) {\n    return a.title.localeCompare(b.title);\n  });\n  \n  var options = 'Select a dictionary entry to link:\\n\\n';\n  for (var i = 0; i < entries.length; i++) {\n    options += (i + 1) + '. ' + entries[i].title + '\\n';\n  }\n  \n  var selection = app.api.ui.prompt(options + '\\nEnter number:');\n  if (!selection) return;\n  \n  var index = parseInt(selection) - 1;\n  if (isNaN(index) || index < 0 || index >= entries.length) {\n    app.api.ui.alert('Invalid selection');\n    return;\n  }\n  \n  var selectedEntry = entries[index];\n  var cell = getCell(state.activeCell);\n  \n  if (!cell) return;\n  \n  if (!cell.dictionaryEntries) {\n    cell.dictionaryEntries = [];\n  }\n  \n  if (cell.dictionaryEntries.indexOf(selectedEntry.id) === -1) {\n    cell.dictionaryEntries.push(selectedEntry.id);\n    state.modified = true;\n    updateInfoPanel();\n  } else {\n    app.api.ui.alert('This cell is already linked to \"' + selectedEntry.title + '\"');\n  }\n}\n\n// Export just the dictionary to a separate file\nfunction exportDictionary() {\n  var fileName = app.api.ui.prompt('Enter file name for dictionary export:', 'dictionary_export.json');\n  if (!fileName) return;\n  \n  if (!fileName.endsWith('.json')) {\n    fileName += '.json';\n  }\n  \n  var filePath = '/Documents/' + fileName;\n  \n  // Prepare data for export\n  var exportData = {\n    dictionary: state.dictionary,\n    metadata: {\n      exportDate: new Date().toISOString(),\n      entryCount: Object.keys(state.dictionary).length,\n      appVersion: '1.0'\n    }\n  };\n  \n  try {\n    if (app.api.fs.fileExists(filePath)) {\n      var overwrite = app.api.ui.confirm(fileName + ' already exists. Overwrite?');\n      if (!overwrite) return;\n    }\n    \n    app.api.fs.writeFile(filePath, JSON.stringify(exportData, null, 2));\n    app.api.ui.showNotification('Dictionary exported as ' + fileName);\n  } catch (error) {\n    app.api.ui.alert('Error exporting dictionary: ' + error.message);\n  }\n}\n\n// Import dictionary from a file\nfunction importDictionary() {\n  var confirmImport = app.api.ui.confirm('Import dictionary entries? This will add to your existing dictionary (duplicate entries will be updated).');\n  if (!confirmImport) return;\n  \n  var files = app.api.fs.listFiles('/Documents');\n  \n  if (!files || files.length === 0) {\n    app.api.ui.alert('No files found in Documents folder');\n    return;\n  }\n  \n  var jsonFiles = [];\n  var fileList = 'Select a JSON file containing dictionary data:\\n\\n';\n  \n  for (var i = 0; i < files.length; i++) {\n    var file = files[i];\n    if (file.type === 'file' && file.name.endsWith('.json')) {\n      jsonFiles.push(file);\n      fileList += (jsonFiles.length) + '. ' + file.name + '\\n';\n    }\n  }\n  \n  if (jsonFiles.length === 0) {\n    app.api.ui.alert('No JSON files found');\n    return;\n  }\n  \n  var fileIndex = app.api.ui.prompt(fileList + '\\nEnter file number:');\n  if (!fileIndex) return;\n  \n  var selectedFile = jsonFiles[parseInt(fileIndex) - 1];\n  if (!selectedFile) {\n    app.api.ui.alert('Invalid selection');\n    return;\n  }\n  \n  try {\n    var content = app.api.fs.readFile(selectedFile.path);\n    if (!content) {\n      app.api.ui.alert('Could not read file');\n      return;\n    }\n    \n    var data = JSON.parse(content);\n    \n    if (!data.dictionary) {\n      app.api.ui.alert('No dictionary data found in this file');\n      return;\n    }\n    \n    // Count entries before import\n    var originalCount = Object.keys(state.dictionary).length;\n    var importCount = 0;\n    var updateCount = 0;\n    \n    // Import entries\n    for (var id in data.dictionary) {\n      var entry = data.dictionary[id];\n      \n      // Check if entry already exists\n      if (state.dictionary[id]) {\n        updateCount++;\n      } else {\n        importCount++;\n      }\n      \n      // Add or update entry\n      state.dictionary[id] = entry;\n      \n      // Register in memory pointers\n      state.memoryPointers[id] = 'dict_' + Object.keys(state.dictionary).length;\n    }\n    \n    state.modified = true;\n    updateDictionaryPanel();\n    \n    app.api.ui.alert('Dictionary import complete\\n\\nImported ' + importCount + ' new entries\\nUpdated ' + updateCount + ' existing entries\\nTotal entries: ' + Object.keys(state.dictionary).length);\n    \n  } catch (error) {\n    app.api.ui.alert('Error importing dictionary: ' + error.message);\n  }\n}\n\n// Handle canvas click to select/activate cells\nfunction handleCanvasClick(e) {\n  if (isDragging) return; // Don't select when dragging/panning\n  \n  var rect = canvas.getBoundingClientRect();\n  var x = e.clientX - rect.left;\n  var y = e.clientY - rect.top;\n  \n  // Convert to canvas coordinates\n  x = x * canvas.width / rect.width;\n  y = y * canvas.height / rect.height;\n  \n  // Apply zoom and pan transformations\n  x = (x - canvas.width/2) / state.settings.zoomLevel + canvas.width/2 - state.settings.panOffset.x;\n  y = (y - canvas.height/2) / state.settings.zoomLevel + canvas.height/2 - state.settings.panOffset.y;\n  \n  var cell = findCellAt(x, y);\n  if (cell) {\n    state.activeCell = cell.id;\n    updateInfoPanel();\n    renderQuadtree(); // Re-render to show selection\n  }\n}\n\n// Find which cell is at the given coordinates\nfunction findCellAt(x, y) {\n  var currentQuadtree = state.quadtrees[state.currentQuadtreeId];\n  if (!currentQuadtree) return null;\n  \n  var canvasWidth = canvas.width;\n  var canvasHeight = canvas.height;\n  \n  function search(node, x0, y0, x1, y1) {\n    if (!node) return null;\n    \n    // Check if point is inside this cell\n    if (x < x0 || x >= x1 || y < y0 || y >= y1) {\n      return null; // Point is outside this cell\n    }\n    \n    // If node has children, search them\n    if (node.children) {\n      var midX = (x0 + x1) / 2;\n      var midY = (y0 + y1) / 2;\n      \n      // Check which quadrant the point is in\n      var quadrant;\n      if (x < midX && y < midY) {\n        quadrant = 0; // Top-left\n      } else if (x >= midX && y < midY) {\n        quadrant = 1; // Top-right\n      } else if (x < midX && y >= midY) {\n        quadrant = 2; // Bottom-left\n      } else {\n        quadrant = 3; // Bottom-right\n      }\n      \n      // Search the appropriate child\n      var child = node.children[quadrant];\n      var childResult;\n      \n      switch(quadrant) {\n        case 0: childResult = search(child, x0, y0, midX, midY); break; // Top-left\n        case 1: childResult = search(child, midX, y0, x1, midY); break; // Top-right\n        case 2: childResult = search(child, x0, midY, midX, y1); break; // Bottom-left\n        case 3: childResult = search(child, midX, midY, x1, y1); break; // Bottom-right\n      }\n      \n      return childResult || node; // Return the child result or this node if child returned null\n    }\n    \n    return node; // This is a leaf node and contains the point\n  }\n  \n  return search(currentQuadtree, 0, 0, canvasWidth, canvasHeight);\n}\n\n// Render the current quadtree to the canvas\nfunction renderQuadtree() {\n  // First ensure the canvas wrapper maintains square aspect ratio\n  maintainSquareAspect();\n  \n  var ctx = canvas.getContext('2d');\n  var currentQuadtree = state.quadtrees[state.currentQuadtreeId];\n  \n  // Clear canvas\n  ctx.fillStyle = '#000';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n  \n  // Save the context state for transformations\n  ctx.save();\n  \n  // Apply zoom and pan\n  ctx.translate(canvas.width/2, canvas.height/2);\n  ctx.scale(state.settings.zoomLevel, state.settings.zoomLevel);\n  ctx.translate(-canvas.width/2 + state.settings.panOffset.x, -canvas.height/2 + state.settings.panOffset.y);\n  \n  // Draw the quadtree\n  drawQuadtree(ctx, currentQuadtree, 0, 0, canvas.width, canvas.height);\n  \n  // Restore the context state\n  ctx.restore();\n  \n  // Update status bar\n  var qtName = state.currentQuadtreeId === 'root' ? \n    'Main Quadtree' : \n    state.quadtrees[state.currentQuadtreeId].name;\n  \n  statusLeft.textContent = qtName + (state.modified ? ' *' : '');\n  statusRight.textContent = 'Zoom: ' + Math.round(state.settings.zoomLevel * 100) + '%';\n}\n\n// Recursively draw the quadtree\nfunction drawQuadtree(ctx, node, x0, y0, x1, y1) {\n  if (!node) return;\n  \n  // Draw this cell\n  ctx.fillStyle = node.color || state.settings.defaultCellColor;\n  ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n  \n  // Draw image if present\n  if (node.image) {\n    var img = new Image();\n    img.src = node.image;\n    \n    try {\n      ctx.drawImage(img, x0, y0, x1 - x0, y1 - y0);\n    } catch (e) {\n      // Ignore errors (likely cross-origin or unloaded image)\n    }\n  }\n  \n  // Draw text content\n  if (node.textContent) {\n    ctx.save();\n    ctx.fillStyle = '#fff';\n    ctx.font = '14px monospace';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    \n    // Wrap text\n    var maxWidth = x1 - x0 - 10;\n    var lineHeight = 16;\n    var centerX = (x0 + x1) / 2;\n    var centerY = (y0 + y1) / 2;\n    var words = node.textContent.split(' ');\n    var line = '';\n    var lines = [];\n    \n    for (var i = 0; i < words.length; i++) {\n      var testLine = line + words[i] + ' ';\n      var metrics = ctx.measureText(testLine);\n      if (metrics.width > maxWidth && i > 0) {\n        lines.push(line);\n        line = words[i] + ' ';\n      } else {\n        line = testLine;\n      }\n    }\n    lines.push(line);\n    \n    // Draw lines of text\n    var startY = centerY - (lines.length - 1) * lineHeight / 2;\n    for (var i = 0; i < lines.length; i++) {\n      ctx.fillText(lines[i], centerX, startY + i * lineHeight);\n    }\n    \n    ctx.restore();\n  }\n  \n  // Draw indicators for special cell properties\n  var indicatorSize = 6;\n  var padding = 5;\n  var indicatorX = x0 + padding;\n  var indicatorY = y0 + padding;\n  \n  // Dictionary entries indicator\n  if (node.dictionaryEntries && node.dictionaryEntries.length > 0) {\n    ctx.save();\n    ctx.fillStyle = '#ffcc00';\n    ctx.beginPath();\n    ctx.arc(indicatorX, indicatorY, indicatorSize, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n    \n    // Move next indicator position\n    indicatorX += (indicatorSize * 2 + padding);\n  }\n  \n  // Nested quadtree indicator\n  if (node.content) {\n    ctx.save();\n    ctx.fillStyle = '#00ccff';\n    ctx.beginPath();\n    ctx.arc(indicatorX, indicatorY, indicatorSize, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n  }\n  \n  // Highlight active cell\n  if (state.activeCell === node.id) {\n    ctx.save();\n    ctx.strokeStyle = '#fff';\n    ctx.lineWidth = 3;\n    ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);\n    ctx.restore();\n  }\n  \n  // If this node has children, draw them\n  if (node.children) {\n    var midX = (x0 + x1) / 2;\n    var midY = (y0 + y1) / 2;\n    \n    drawQuadtree(ctx, node.children[0], x0, y0, midX, midY);  // Top-left\n    drawQuadtree(ctx, node.children[1], midX, y0, x1, midY);  // Top-right\n    drawQuadtree(ctx, node.children[2], x0, midY, midX, y1);  // Bottom-left\n    drawQuadtree(ctx, node.children[3], midX, midY, x1, y1);  // Bottom-right\n  }\n  \n  // Draw grid lines if enabled\n  if (state.settings.showGrid) {\n    ctx.save();\n    ctx.strokeStyle = state.settings.gridColor;\n    ctx.lineWidth = 1;\n    ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);\n    ctx.restore();\n  }\n}\n\n// Get a cell by its ID with memory pointer optimization\nfunction getCell(cellId) {\n  // Check if we have a direct memory pointer\n  var pointer = state.memoryPointers[cellId];\n  if (pointer && pointer.startsWith('cell_') && state.memoryPointers[pointer]) {\n    return state.memoryPointers[pointer];\n  }\n  \n  // Otherwise use standard traversal\n  function search(node) {\n    if (!node) return null;\n    if (node.id === cellId) {\n      // Cache the result in memory pointers for faster future access\n      state.memoryPointers[cellId] = 'cell_' + cellId;\n      state.memoryPointers['cell_' + cellId] = node;\n      return node;\n    }\n    \n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        var result = search(node.children[i]);\n        if (result) return result;\n      }\n    }\n    \n    return null;\n  }\n  \n  // Parse the cell ID to determine which quadtree to search\n  var parts = cellId.split('/');\n  var quadtreeId = parts[0];\n  \n  if (state.quadtrees[quadtreeId]) {\n    return search(state.quadtrees[quadtreeId]);\n  }\n  \n  // If not found, search all quadtrees (slower fallback)\n  for (var qtId in state.quadtrees) {\n    var result = search(state.quadtrees[qtId]);\n    if (result) return result;\n  }\n  \n  return null;\n}\n\n// Split a cell into four children\nfunction splitCell(cellId) {\n  var cell = getCell(cellId);\n  if (!cell || cell.children) return;\n  \n  // Get the current depth\n  var depth = cellId.split('/').length;\n  if (depth > state.settings.maxDepth) {\n    app.api.ui.alert('Maximum quadtree depth reached (' + state.settings.maxDepth + '). Cannot split further.');\n    return;\n  }\n  \n  // Create four child quadrants with proper memory management\n  cell.children = [];\n  \n  for (var i = 0; i < 4; i++) {\n    var childId = cell.id + '/' + i;\n    var child = {\n      id: childId,\n      color: cell.color,\n      textContent: '',\n      image: null,\n      dictionaryEntries: [],\n      children: null\n    };\n    \n    // Register in memory pointers\n    state.memoryPointers[childId] = 'cell_' + childId;\n    state.memoryPointers['cell_' + childId] = child;\n    \n    cell.children.push(child);\n  }\n  \n  state.modified = true;\n  renderQuadtree();\n}\n\n// Reset a cell to its default state\nfunction resetCell(cellId) {\n  var cell = getCell(cellId);\n  if (!cell) return;\n  \n  var confirm = app.api.ui.confirm('Reset this cell? This will clear all content, children, and remove nested quadtree if present.');\n  if (!confirm) return;\n  \n  // Remove children from memory pointers\n  if (cell.children) {\n    cleanupCellMemory(cell);\n  }\n  \n  // Remove nested quadtree if present\n  if (cell.content) {\n    var quadtreeId = cell.content;\n    cleanupQuadtreeMemory(quadtreeId);\n    delete state.quadtrees[quadtreeId];\n  }\n  \n  cell.children = null;\n  cell.content = null;\n  cell.color = state.settings.defaultCellColor;\n  cell.textContent = '';\n  cell.image = null;\n  cell.dictionaryEntries = [];\n  \n  state.modified = true;\n  updateInfoPanel();\n  renderQuadtree();\n}\n\n// Clean up memory pointers for a cell and its children\nfunction cleanupCellMemory(cell) {\n  if (!cell) return;\n  \n  // Remove this cell from memory pointers\n  delete state.memoryPointers[cell.id];\n  delete state.memoryPointers['cell_' + cell.id];\n  \n  // Recursively clean up children\n  if (cell.children) {\n    for (var i = 0; i < cell.children.length; i++) {\n      cleanupCellMemory(cell.children[i]);\n    }\n  }\n}\n\n// Clean up memory pointers for a quadtree\nfunction cleanupQuadtreeMemory(quadtreeId) {\n  var quadtree = state.quadtrees[quadtreeId];\n  if (!quadtree) return;\n  \n  // Recursively clean up all cells in the quadtree\n  cleanupCellMemory(quadtree);\n  \n  // Remove the quadtree from memory pointers\n  delete state.memoryPointers[quadtreeId];\n}\n\n// Enter a cell (navigate to it as a new quadtree)\nfunction enterCell(cellId) {\n  var cell = getCell(cellId);\n  if (!cell) return;\n  \n  // Check if this cell already has a nested quadtree\n  if (!cell.content) {\n    // Create a new quadtree for this cell\n    var newQuadtreeId = 'qt_' + Date.now();\n    state.quadtrees[newQuadtreeId] = {\n      id: newQuadtreeId,\n      name: getCellPath(cellId),\n      children: null,\n      content: null,\n      color: state.settings.defaultCellColor,\n      textContent: '',\n      image: null,\n      dictionaryEntries: []\n    };\n    \n    // Register in memory pointers\n    state.memoryPointers[newQuadtreeId] = 'quadtree_' + newQuadtreeId;\n    state.memoryPointers['quadtree_' + newQuadtreeId] = state.quadtrees[newQuadtreeId];\n    \n    // Link the cell to this quadtree\n    cell.content = newQuadtreeId;\n    state.modified = true;\n  }\n  \n  // Navigate to the quadtree\n  state.history.push(state.currentQuadtreeId);\n  state.currentQuadtreeId = cell.content;\n  state.activeCell = null;\n  \n  // Reset view when entering a new quadtree\n  resetView(false); // Don't render yet\n  \n  updateInfoPanel();\n  renderQuadtree();\n}\n\n// Navigate back to previous quadtree\nfunction navigateBack() {\n  if (state.history.length <= 1) return;\n  \n  state.currentQuadtreeId = state.history.pop();\n  state.activeCell = null;\n  \n  // Reset view when navigating back\n  resetView(false); // Don't render yet\n  \n  updateInfoPanel();\n  renderQuadtree();\n}\n\n// Zoom in on the quadtree\nfunction zoomIn() {\n  state.settings.zoomLevel *= 1.2;\n  if (state.settings.zoomLevel > 10) {\n    state.settings.zoomLevel = 10; // Maximum zoom level\n  }\n  renderQuadtree();\n}\n\n// Zoom out from the quadtree\nfunction zoomOut() {\n  state.settings.zoomLevel /= 1.2;\n  if (state.settings.zoomLevel < 0.1) {\n    state.settings.zoomLevel = 0.1; // Minimum zoom level\n  }\n  renderQuadtree();\n}\n\n// Reset view (zoom and pan)\nfunction resetView(doRender) {\n  state.settings.zoomLevel = 1.0;\n  state.settings.panOffset = { x: 0, y: 0 };\n  \n  if (doRender !== false) {\n    renderQuadtree();\n  }\n}\n\n// Toggle between explore and dictionary modes\nfunction toggleViewMode(mode) {\n  if (mode) {\n    state.viewMode = mode;\n  } else {\n    state.viewMode = state.viewMode === 'explore' ? 'dictionary' : 'explore';\n  }\n  \n  if (state.viewMode === 'explore') {\n    modeToggleBtn.textContent = 'Dictionary';\n    canvasContainer.style.display = 'flex';\n    infoPanel.style.display = 'block';\n    dictionaryPanel.style.display = 'none';\n  } else {\n    modeToggleBtn.textContent = 'Explorer';\n    canvasContainer.style.display = 'none';\n    infoPanel.style.display = 'none';\n    dictionaryPanel.style.display = 'flex';\n    updateDictionaryPanel();\n  }\n}\n\n// Update the info panel to reflect current state\nfunction updateInfoPanel() {\n  setupInfoPanel();\n}\n\n// Update the dictionary panel to reflect current state\nfunction updateDictionaryPanel() {\n  setupDictionaryPanel();\n}\n\n// Create a new quadtree\nfunction newQuadtree() {\n  if (state.modified) {\n    var save = app.api.ui.confirm('Current quadtree has unsaved changes. Save before creating new?');\n    if (save) {\n      saveQuadtree(function() {\n        resetQuadtree();\n      });\n      return;\n    }\n  }\n  \n  resetQuadtree();\n}\n\n// Reset to a new empty quadtree\nfunction resetQuadtree() {\n  // Clean up memory pointers\n  state.memoryPointers = {};\n  \n  // Create new root quadtree\n  state.quadtrees = {\n    'root': {\n      id: 'root',\n      name: 'Main Quadtree',\n      children: null,\n      content: null,\n      color: state.settings.defaultCellColor,\n      textContent: '',\n      image: null,\n      dictionaryEntries: []\n    }\n  };\n  \n  // Register in memory pointers\n  state.memoryPointers['root'] = 'quadtree_root';\n  state.memoryPointers['quadtree_root'] = state.quadtrees.root;\n  \n  state.currentQuadtreeId = 'root';\n  state.history = ['root'];\n  state.dictionary = {};\n  state.activeCell = null;\n  state.selectedDictionaryEntry = null;\n  state.modified = false;\n  \n  // Reset view\n  resetView(false);\n  \n  updateInfoPanel();\n  renderQuadtree();\n}\n\n// Save the current quadtree to the filesystem\nfunction saveQuadtree(callback) {\n  var fileName = app.api.ui.prompt('Enter file name to save:', 'quadtree.qdt');\n  if (!fileName) return;\n  \n  if (!fileName.endsWith('.qdt')) {\n    fileName += '.qdt';\n  }\n  \n  var filePath = '/Documents/' + fileName;\n  \n  // Prepare data for saving\n  var saveData = {\n    quadtrees: state.quadtrees,\n    dictionary: state.dictionary,\n    settings: state.settings,\n    metadata: {\n      version: '1.0',\n      saveDate: new Date().toISOString(),\n      quadtreeCount: Object.keys(state.quadtrees).length,\n      dictionaryEntryCount: Object.keys(state.dictionary).length\n    }\n  };\n  \n  try {\n    if (app.api.fs.fileExists(filePath)) {\n      var overwrite = app.api.ui.confirm(fileName + ' already exists. Overwrite?');\n      if (!overwrite) return;\n    }\n    \n    app.api.fs.writeFile(filePath, JSON.stringify(saveData));\n    state.modified = false;\n    app.api.ui.showNotification('Quadtree saved as ' + fileName);\n    \n    if (callback) callback();\n  } catch (error) {\n    app.api.ui.alert('Error saving file: ' + error.message);\n  }\n}\n\n// Open a quadtree from the filesystem\nfunction openQuadtree() {\n  if (state.modified) {\n    var save = app.api.ui.confirm('Current quadtree has unsaved changes. Save before opening?');\n    if (save) {\n      saveQuadtree(function() {\n        showOpenDialog();\n      });\n      return;\n    }\n  }\n  \n  showOpenDialog();\n}\n\n// Show the open file dialog\nfunction showOpenDialog() {\n  var files = app.api.fs.listFiles('/Documents');\n  \n  if (!files || files.length === 0) {\n    app.api.ui.alert('No files found in Documents folder');\n    return;\n  }\n  \n  var qdtFiles = [];\n  var fileList = 'Select a quadtree file to open:\\n\\n';\n  \n  for (var i = 0; i < files.length; i++) {\n    var file = files[i];\n    if (file.type === 'file' && file.name.endsWith('.qdt')) {\n      qdtFiles.push(file);\n      fileList += (qdtFiles.length) + '. ' + file.name + '\\n';\n    }\n  }\n  \n  if (qdtFiles.length === 0) {\n    app.api.ui.alert('No quadtree files found');\n    return;\n  }\n  \n  var fileIndex = app.api.ui.prompt(fileList + '\\nEnter file number:');\n  if (!fileIndex) return;\n  \n  var selectedFile = qdtFiles[parseInt(fileIndex) - 1];\n  if (!selectedFile) {\n    app.api.ui.alert('Invalid selection');\n    return;\n  }\n  \n  loadQuadtreeFile(selectedFile.path);\n}\n\n// Load a quadtree file from the filesystem\nfunction loadQuadtreeFile(path) {\n  try {\n    var content = app.api.fs.readFile(path);\n    if (!content) {\n      app.api.ui.alert('Could not read file');\n      return;\n    }\n    \n    var data = JSON.parse(content);\n    \n    if (!data.quadtrees || !data.dictionary) {\n      app.api.ui.alert('Invalid quadtree file format');\n      return;\n    }\n    \n    // Clean up existing memory pointers\n    state.memoryPointers = {};\n    \n    // Load the data\n    state.quadtrees = data.quadtrees;\n    state.dictionary = data.dictionary;\n    \n    // Rebuild memory pointers\n    rebuildMemoryPointers();\n    \n    // Merge settings, preserving defaults for any missing settings\n    if (data.settings) {\n      for (var key in data.settings) {\n        state.settings[key] = data.settings[key];\n      }\n    }\n    \n    state.currentQuadtreeId = 'root';\n    state.history = ['root'];\n    state.activeCell = null;\n    state.selectedDictionaryEntry = null;\n    state.modified = false;\n    \n    // Reset view\n    resetView(false);\n    \n    updateInfoPanel();\n    renderQuadtree();\n    \n    app.api.ui.showNotification('Quadtree loaded from ' + path.split('/').pop());\n  } catch (error) {\n    app.api.ui.alert('Error loading file: ' + error.message);\n  }\n}\n\n// Rebuild memory pointers after loading\nfunction rebuildMemoryPointers() {\n  // Register quadtrees in memory pointers\n  for (var qtId in state.quadtrees) {\n    state.memoryPointers[qtId] = 'quadtree_' + qtId;\n    state.memoryPointers['quadtree_' + qtId] = state.quadtrees[qtId];\n    \n    // Register all cells in this quadtree\n    registerCellPointers(state.quadtrees[qtId]);\n  }\n  \n  // Register dictionary entries\n  for (var entryId in state.dictionary) {\n    state.memoryPointers[entryId] = 'dict_' + entryId;\n  }\n}\n\n// Register cell and its children in memory pointers\nfunction registerCellPointers(cell) {\n  if (!cell) return;\n  \n  state.memoryPointers[cell.id] = 'cell_' + cell.id;\n  state.memoryPointers['cell_' + cell.id] = cell;\n  \n  if (cell.children) {\n    for (var i = 0; i < cell.children.length; i++) {\n      registerCellPointers(cell.children[i]);\n    }\n  }\n}\n\n// Export the quadtree to a JSON file\nfunction exportToJson() {\n  var fileName = app.api.ui.prompt('Enter file name for export:', 'quadtree_export.json');\n  if (!fileName) return;\n  \n  if (!fileName.endsWith('.json')) {\n    fileName += '.json';\n  }\n  \n  var filePath = '/Documents/' + fileName;\n  \n  // Prepare data for export\n  var exportData = {\n    quadtrees: state.quadtrees,\n    dictionary: state.dictionary,\n    settings: state.settings,\n    metadata: {\n      version: '1.0',\n      exportDate: new Date().toISOString(),\n      quadtreeCount: Object.keys(state.quadtrees).length,\n      dictionaryEntryCount: Object.keys(state.dictionary).length,\n      cellCount: countAllCells()\n    }\n  };\n  \n  try {\n    if (app.api.fs.fileExists(filePath)) {\n      var overwrite = app.api.ui.confirm(fileName + ' already exists. Overwrite?');\n      if (!overwrite) return;\n    }\n    \n    app.api.fs.writeFile(filePath, JSON.stringify(exportData, null, 2));\n    app.api.ui.showNotification('Quadtree exported as ' + fileName);\n  } catch (error) {\n    app.api.ui.alert('Error exporting file: ' + error.message);\n  }\n}\n\n// Count all cells in all quadtrees\nfunction countAllCells() {\n  var count = 0;\n  \n  function countCells(node) {\n    if (!node) return 0;\n    \n    var nodeCount = 1; // Count this node\n    \n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        nodeCount += countCells(node.children[i]);\n      }\n    }\n    \n    return nodeCount;\n  }\n  \n  for (var qtId in state.quadtrees) {\n    count += countCells(state.quadtrees[qtId]);\n  }\n  \n  return count;\n}\n\n// Import a quadtree from a JSON file\nfunction importFromJson() {\n  if (state.modified) {\n    var save = app.api.ui.confirm('Current quadtree has unsaved changes. Save before importing?');\n    if (save) {\n      saveQuadtree(function() {\n        showImportDialog();\n      });\n      return;\n    }\n  }\n  \n  showImportDialog();\n}\n\n// Show the import file dialog\nfunction showImportDialog() {\n  var files = app.api.fs.listFiles('/Documents');\n  \n  if (!files || files.length === 0) {\n    app.api.ui.alert('No files found in Documents folder');\n    return;\n  }\n  \n  var jsonFiles = [];\n  var fileList = 'Select a JSON file to import:\\n\\n';\n  \n  for (var i = 0; i < files.length; i++) {\n    var file = files[i];\n    if (file.type === 'file' && file.name.endsWith('.json')) {\n      jsonFiles.push(file);\n      fileList += (jsonFiles.length) + '. ' + file.name + '\\n';\n    }\n  }\n  \n  if (jsonFiles.length === 0) {\n    app.api.ui.alert('No JSON files found');\n    return;\n  }\n  \n  var fileIndex = app.api.ui.prompt(fileList + '\\nEnter file number:');\n  if (!fileIndex) return;\n  \n  var selectedFile = jsonFiles[parseInt(fileIndex) - 1];\n  if (!selectedFile) {\n    app.api.ui.alert('Invalid selection');\n    return;\n  }\n  \n  loadJsonFile(selectedFile.path);\n}\n\n// Load a JSON file and import its quadtree data\nfunction loadJsonFile(path) {\n  try {\n    var content = app.api.fs.readFile(path);\n    if (!content) {\n      app.api.ui.alert('Could not read file');\n      return;\n    }\n    \n    var data = JSON.parse(content);\n    \n    if (!data.quadtrees) {\n      app.api.ui.alert('Invalid quadtree data format');\n      return;\n    }\n    \n    // Clean up existing memory pointers\n    state.memoryPointers = {};\n    \n    // Load the data\n    state.quadtrees = data.quadtrees;\n    \n    // Load dictionary if present\n    if (data.dictionary) {\n      state.dictionary = data.dictionary;\n    }\n    \n    // Rebuild memory pointers\n    rebuildMemoryPointers();\n    \n    // Merge settings if present\n    if (data.settings) {\n      for (var key in data.settings) {\n        state.settings[key] = data.settings[key];\n      }\n    }\n    \n    state.currentQuadtreeId = 'root';\n    state.history = ['root'];\n    state.activeCell = null;\n    state.selectedDictionaryEntry = null;\n    state.modified = true; // Mark as modified since we imported\n    \n    // Reset view\n    resetView(false);\n    \n    updateInfoPanel();\n    renderQuadtree();\n    \n    app.api.ui.showNotification('Quadtree imported from ' + path.split('/').pop());\n  } catch (error) {\n    app.api.ui.alert('Error importing file: ' + error.message);\n  }\n}\n\n// Show the settings dialog\nfunction showSettings() {\n  var settingsHtml = 'Quadtree Settings:\\n\\n' +\n    '1. Show Grid: ' + (state.settings.showGrid ? 'On' : 'Off') + '\\n' +\n    '2. Grid Color: ' + state.settings.gridColor + '\\n' +\n    '3. Default Cell Color: ' + state.settings.defaultCellColor + '\\n' +\n    '4. Max Depth: ' + state.settings.maxDepth + '\\n' +\n    '5. Enforce Square Images: ' + (state.settings.enforceSquareImages ? 'On' : 'Off') + '\\n\\n' +\n    'Enter option number to change:';\n  \n  var option = app.api.ui.prompt(settingsHtml);\n  if (!option) return;\n  \n  var num = parseInt(option);\n  if (isNaN(num) || num < 1 || num > 5) {\n    app.api.ui.alert('Invalid option');\n    return;\n  }\n  \n  switch(num) {\n    case 1: // Toggle Show Grid\n      state.settings.showGrid = !state.settings.showGrid;\n      break;\n      \n    case 2: // Change Grid Color\n      var color = app.api.ui.prompt('Enter grid color (e.g. #333333):', state.settings.gridColor);\n      if (color) {\n        state.settings.gridColor = color;\n      }\n      break;\n      \n    case 3: // Change Default Cell Color\n      var color = app.api.ui.prompt('Enter default cell color (e.g. #1a1a1a):', state.settings.defaultCellColor);\n      if (color) {\n        state.settings.defaultCellColor = color;\n      }\n      break;\n      \n    case 4: // Change Max Depth\n      var depth = app.api.ui.prompt('Enter maximum quadtree depth (1-10):', state.settings.maxDepth);\n      if (depth) {\n        var depthNum = parseInt(depth);\n        if (!isNaN(depthNum) && depthNum >= 1 && depthNum <= 10) {\n          state.settings.maxDepth = depthNum;\n        } else {\n          app.api.ui.alert('Invalid depth value. Must be between 1 and 10.');\n        }\n      }\n      break;\n      \n    case 5: // Toggle Square Images\n      state.settings.enforceSquareImages = !state.settings.enforceSquareImages;\n      break;\n  }\n  \n  state.modified = true;\n  renderQuadtree();\n}\n\n// Show help dialog\nfunction showHelp() {\n  var helpText = 'DYNAMIC QUADTREE EXPLORER HELP\\n\\n' +\n    'BASICS:\\n' +\n    '- All cells are perfectly square, maintaining geometric precision\\n' +\n    '- Images are automatically cropped to square format\\n' +\n    '- Navigate with mouse clicks, keyboard arrows, and zoom controls\\n\\n' +\n    'NAVIGATION:\\n' +\n    '- Click on a cell to select it\\n' +\n    '- Use \"Back\" button to navigate up levels\\n' +\n    '- Use \"Enter Cell\" to navigate into a cell\\n' +\n    '- Arrow keys: Pan the view\\n' +\n    '- +/- keys: Zoom in/out\\n' +\n    '- R key: Reset view\\n' +\n    '- B key: Go back\\n' +\n    '- Enter key: Enter selected cell\\n\\n' +\n    'CELL OPERATIONS:\\n' +\n    '- Split Cell: Divide a cell into four quadrants\\n' +\n    '- Enter Cell: Navigate into a cell as a new quadtree\\n' +\n    '- Reset Cell: Clear all cell content and children\\n\\n' +\n    'CELL CONTENT:\\n' +\n    '- Text: Add descriptive text to cells\\n' +\n    '- Color: Change background color\\n' +\n    '- Image: Upload or paste square images\\n' +\n    '- Dictionary: Link to knowledge base entries\\n\\n' +\n    'DICTIONARY:\\n' +\n    '- Create entries for scientific concepts\\n' +\n    '- Link entries to multiple cells\\n' +\n    '- Navigate between dictionary and cells\\n' +\n    '- Export dictionary separately for sharing\\n\\n' +\n    'MEMORY MANAGEMENT:\\n' +\n    '- System uses efficient memory pointers\\n' +\n    '- See memory usage in cell properties\\n' +\n    '- Automatic garbage collection when resetting cells\\n\\n' +\n    'FILE OPERATIONS:\\n' +\n    '- Save/Open: Store and retrieve quadtrees (.qdt files)\\n' +\n    '- Export/Import: Share as JSON with metadata\\n\\n' +\n    'INDICATORS:\\n' +\n    '- Yellow dot: Cell has dictionary entries\\n' +\n    '- Blue dot: Cell contains a nested quadtree\\n' +\n    '- White border: Currently selected cell';\n  \n  app.api.ui.alert(helpText);\n}\n\n// Handle window resize events\nwindow.addEventListener('resize', function() {\n  maintainSquareAspect();\n  renderQuadtree();\n});\n\n// Initial setup\nfunction initialize() {\n  // Set up the info panel\n  setupInfoPanel();\n  \n  // Set up the dictionary panel\n  setupDictionaryPanel();\n  \n  // Initial render\n  renderQuadtree();\n}\n\n// Start the application\ninitialize();"
}